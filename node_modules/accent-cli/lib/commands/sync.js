"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Vendor
const command_1 = require("@oclif/command");
const fs_1 = require("fs");
// Command
const base_1 = require("../base");
// Formatters
const project_add_translations_1 = require("../services/formatters/project-add-translations");
const project_export_1 = require("../services/formatters/project-export");
const project_sync_1 = require("../services/formatters/project-sync");
const document_paths_fetcher_1 = require("../services/document-paths-fetcher");
const commit_operation_1 = require("../services/formatters/commit-operation");
const document_export_1 = require("../services/formatters/document-export");
const hook_runner_1 = require("../services/hook-runner");
const revision_slug_fetcher_1 = require("../services/revision-slug-fetcher");
// Types
const document_config_1 = require("../types/document-config");
class Sync extends base_1.default {
    async run() {
        const { flags } = this.parse(Sync);
        const documents = this.projectConfig.files();
        // From all the documentConfigs, do the sync or peek operations and log the results.
        new project_sync_1.default().log(this.project);
        for (const document of documents) {
            await new hook_runner_1.default(document).run(document_config_1.Hooks.beforeSync);
            await Promise.all(this.syncDocumentConfig(document));
            await new hook_runner_1.default(document).run(document_config_1.Hooks.afterSync);
        }
        // After syncing (and writing) the files in Accent, the list of documents could have changed.
        if (!flags['dry-run'])
            await this.refreshProject();
        if (this.project.revisions.length > 1 && flags['add-translations']) {
            new project_add_translations_1.default().log(this.project);
            for (const document of documents) {
                await new hook_runner_1.default(document).run(document_config_1.Hooks.beforeAddTranslations);
                await Promise.all(this.addTranslationsDocumentConfig(document));
                await new hook_runner_1.default(document).run(document_config_1.Hooks.afterAddTranslations);
            }
        }
        if (flags['dry-run'])
            return;
        const formatter = new document_export_1.default();
        // From all the documentConfigs, do the export, write to local file and log the results.
        new project_export_1.default().log();
        for (const document of documents) {
            await new hook_runner_1.default(document).run(document_config_1.Hooks.beforeExport);
            const targets = new document_paths_fetcher_1.default().fetch(this.project, document);
            await Promise.all(targets.map(async ({ path, language, documentPath }) => {
                const localFile = document.fetchLocalFile(documentPath, path);
                if (!localFile)
                    return new Promise((resolve) => resolve());
                formatter.log(localFile);
                return document.export(localFile, language, documentPath, flags);
            }));
            await new hook_runner_1.default(document).run(document_config_1.Hooks.afterExport);
        }
    }
    syncDocumentConfig(document) {
        const { flags } = this.parse(Sync);
        const formatter = new commit_operation_1.default();
        return document.paths.map(async (path) => {
            const operations = await document.sync(this.project, path, flags);
            const documentPath = document.parseDocumentName(path, document.config);
            if (operations.sync && !operations.peek) {
                formatter.logSync(path, documentPath);
            }
            if (operations.peek) {
                formatter.logPeek(path, documentPath, operations.peek);
            }
            return operations;
        });
    }
    addTranslationsDocumentConfig(document) {
        const { flags } = this.parse(Sync);
        const formatter = new commit_operation_1.default();
        const masterLanguage = revision_slug_fetcher_1.fetchFromRevision(this.project.masterRevision);
        const targets = new document_paths_fetcher_1.default()
            .fetch(this.project, document)
            .filter(({ language }) => language !== masterLanguage);
        const existingTargets = targets.filter(({ path }) => fs_1.existsSync(path));
        if (existingTargets.length === 0) {
            targets.forEach(({ path }) => formatter.logEmptyExistingTarget(path));
        }
        if (targets.length === 0) {
            formatter.logEmptyTarget(document.config.source);
        }
        return existingTargets.map(async ({ path, language }) => {
            const documentPath = document.parseDocumentName(path, document.config);
            const operations = await document.addTranslations(path, language, documentPath, flags);
            if (operations.addTranslations && !operations.peek) {
                formatter.logAddTranslations(path, documentPath);
            }
            if (operations.peek) {
                formatter.logPeek(path, documentPath, operations.peek);
            }
            return operations;
        });
    }
}
Sync.description = 'Sync files in Accent and write them to your local filesystem';
Sync.examples = [`$ accent sync`];
Sync.args = [];
Sync.flags = {
    'add-translations': command_1.flags.boolean({
        description: 'Add translations in Accent to help translators if you already have translated strings',
    }),
    'dry-run': command_1.flags.boolean({
        default: false,
        description: 'Do not write the file from the export _after_ the operation',
    }),
    'merge-type': command_1.flags.string({
        default: 'smart',
        description: 'Will be used in the add translations call as the "merge_type" param',
        options: ['smart', 'passive', 'force'],
    }),
    'order-by': command_1.flags.string({
        default: 'index',
        description: 'Will be used in the export call as the order of the keys',
        options: ['index', 'key-asc'],
    }),
    'sync-type': command_1.flags.string({
        default: 'smart',
        description: 'Will be used in the sync call as the "sync_type" param',
        options: ['smart', 'passive'],
    }),
};
exports.default = Sync;
