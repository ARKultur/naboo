"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Vendor
const FormData = require("form-data");
const fs = require("fs-extra");
const mkdirp = require("mkdirp");
const node_fetch_1 = require("node-fetch");
const path = require("path");
// Services
const revision_slug_fetcher_1 = require("./revision-slug-fetcher");
const tree_1 = require("./tree");
const document_config_1 = require("../types/document-config");
const ERROR_THRESHOLD_STATUS_CODE = 400;
class Document {
    constructor(documentConfig, config) {
        this.config = this.resolveNamePattern(documentConfig);
        this.apiKey = config.apiKey;
        this.apiUrl = config.apiUrl;
        this.target = this.config.target;
        this.paths = new tree_1.default(this.config).list();
    }
    refreshPaths() {
        this.paths = new tree_1.default(this.config).list();
    }
    async sync(project, file, options) {
        const masterLanguage = revision_slug_fetcher_1.fetchFromRevision(project.masterRevision);
        const formData = new FormData();
        formData.append('file', fs.createReadStream(file));
        formData.append('document_path', this.parseDocumentName(file, this.config));
        formData.append('document_format', this.config.format);
        formData.append('language', masterLanguage);
        let url = `${this.apiUrl}/sync`;
        if (options['dry-run'])
            url = `${url}/peek`;
        if (options['sync-type']) {
            formData.append('sync_type', options['sync-type']);
        }
        const response = await node_fetch_1.default(url, {
            body: formData,
            headers: this.authorizationHeader(),
            method: 'POST',
        });
        return this.handleResponse(response, options, "sync" /* Sync */);
    }
    async addTranslations(file, language, documentPath, options) {
        const formData = new FormData();
        formData.append('file', fs.createReadStream(file));
        formData.append('document_path', documentPath);
        formData.append('document_format', this.config.format);
        formData.append('language', language);
        let url = `${this.apiUrl}/add-translations`;
        if (options['dry-run'])
            url = `${url}/peek`;
        if (options['merge-type']) {
            formData.append('merge_type', options['merge-type']);
        }
        const response = await node_fetch_1.default(url, {
            body: formData,
            headers: this.authorizationHeader(),
            method: 'POST',
        });
        return this.handleResponse(response, options, "addTranslations" /* AddTranslation */);
    }
    fetchLocalFile(documentPath, localPath) {
        return this.paths.reduce((memo, path) => {
            if (this.parseDocumentName(path, this.config) === documentPath) {
                return localPath;
            }
            else {
                return memo;
            }
        }, null);
    }
    async export(file, language, documentPath, options) {
        const query = [
            ['document_path', documentPath],
            ['document_format', this.config.format],
            ['order_by', options['order-by']],
            ['language', language],
        ];
        const url = `${this.apiUrl}/export?${this.encodeQuery(query)}`;
        const response = await node_fetch_1.default(url, {
            headers: this.authorizationHeader(),
        });
        return this.writeResponseToFile(response, file);
    }
    async exportJipt(file, documentPath) {
        const query = [
            ['document_path', documentPath],
            ['document_format', this.config.format],
        ];
        const url = `${this.apiUrl}/jipt-export?${this.encodeQuery(query)}`;
        const response = await node_fetch_1.default(url, {
            headers: this.authorizationHeader(),
        });
        return this.writeResponseToFile(response, file);
    }
    parseDocumentName(file, config) {
        if (config.namePattern === document_config_1.NamePattern.parentDirectory) {
            const targetPrefixMatch = config.target.match(/(\w+\/)+/);
            if (targetPrefixMatch) {
                return path.dirname(file).replace(targetPrefixMatch[0], '');
            }
            else {
                return path.dirname(file);
            }
        }
        const basename = path.basename(file).replace(path.extname(file), '');
        if (config.namePattern === document_config_1.NamePattern.fileWithSlugSuffix) {
            return basename.replace(path.extname(basename), '');
        }
        return basename;
    }
    encodeQuery(params) {
        return params
            .map(([name, value]) => `${name}=${encodeURIComponent(value)}`)
            .join('&');
    }
    authorizationHeader() {
        return { authorization: `Bearer ${this.apiKey}` };
    }
    resolveNamePattern(config) {
        if (config.namePattern)
            return config;
        let pattern = document_config_1.NamePattern.parentDirectory;
        if (config.target.match(/\%slug\%\//) || !config.source.match(/\//)) {
            pattern = document_config_1.NamePattern.file;
        }
        if (config.target.match(/\.\%slug\%\./)) {
            pattern = document_config_1.NamePattern.fileWithSlugSuffix;
        }
        config.namePattern = pattern;
        return config;
    }
    async writeResponseToFile(response, file) {
        return new Promise((resolve, reject) => {
            mkdirp.sync(path.dirname(file));
            const fileStream = fs.createWriteStream(file, { autoClose: true });
            response.body.pipe(fileStream);
            response.body.on('error', reject);
            fileStream.on('finish', resolve);
        });
    }
    async handleResponse(response, options, operationName) {
        if (!options['dry-run']) {
            if (response.status >= ERROR_THRESHOLD_STATUS_CODE) {
                return { [operationName]: { success: false }, peek: false };
            }
            return { [operationName]: { success: true }, peek: false };
        }
        else {
            const { data } = await response.json();
            return { peek: data, [operationName]: { success: true } };
        }
    }
}
exports.default = Document;
